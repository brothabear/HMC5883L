<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>HMC5883L: HMC5883L Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HMC5883L
   &#160;<span id="projectnumber">0.2</span>
   </div>
   <div id="projectbrief">Library for I2C communication with HMC5883L over Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_h_m_c5883_l.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Modules</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_h_m_c5883_l-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HMC5883L Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab552ed5dd985c500aa37ac11f9ed3eed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#ab552ed5dd985c500aa37ac11f9ed3eed">HMC5883L</a> ()</td></tr>
<tr class="memdesc:ab552ed5dd985c500aa37ac11f9ed3eed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_h_m_c5883_l.html">HMC5883L</a> 3-axis digital magnetometer class object.  <a href="#ab552ed5dd985c500aa37ac11f9ed3eed">More...</a><br /></td></tr>
<tr class="separator:ab552ed5dd985c500aa37ac11f9ed3eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce69beed189b56b294775e273768b87"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#adce69beed189b56b294775e273768b87">initialize</a> (bool noConfig=false)</td></tr>
<tr class="separator:adce69beed189b56b294775e273768b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef71c4ee9d0a549cb86f6bb90bb238b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_vec3.html">Vec3</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#aef71c4ee9d0a549cb86f6bb90bb238b2">readRawValues</a> (uint8_t *saturated=NULL)</td></tr>
<tr class="separator:aef71c4ee9d0a549cb86f6bb90bb238b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac270d4672e1e0ed759ee07a504f2ab00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#ac270d4672e1e0ed759ee07a504f2ab00">readScaledValues</a> (uint8_t *saturated=NULL)</td></tr>
<tr class="separator:ac270d4672e1e0ed759ee07a504f2ab00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16828549ee509bb4fa8a3995424c8889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#a16828549ee509bb4fa8a3995424c8889">readScaledValuesSingle</a> (uint8_t *saturated=NULL, uint32_t max_retries=0, uint32_t delay_time=<a class="el" href="group___general_constants.html#ga26afbcf737f1add055ea8929c03648a9">HMC_SLEEP_DELAY</a>)</td></tr>
<tr class="separator:a16828549ee509bb4fa8a3995424c8889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc926cb263a856f4f3f77092d550139"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#a6cc926cb263a856f4f3f77092d550139">readCalibratedValues</a> (uint8_t *saturated=NULL)</td></tr>
<tr class="separator:a6cc926cb263a856f4f3f77092d550139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb30a00675cd4a71809b103b06edfaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#acfb30a00675cd4a71809b103b06edfaa">readCalibratedValuesSingle</a> (uint8_t *saturated=NULL, uint32_t max_retries=0, float delay_time=<a class="el" href="group___general_constants.html#ga26afbcf737f1add055ea8929c03648a9">HMC_SLEEP_DELAY</a>)</td></tr>
<tr class="separator:acfb30a00675cd4a71809b103b06edfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8557a9869b1b8be968db2eb26eb373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#afe8557a9869b1b8be968db2eb26eb373">getCalibration</a> (bool update, uint8_t *saturated=NULL, uint32_t max_retries=0, float delay_time=<a class="el" href="group___general_constants.html#ga26afbcf737f1add055ea8929c03648a9">HMC_SLEEP_DELAY</a>)</td></tr>
<tr class="separator:afe8557a9869b1b8be968db2eb26eb373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041550377640f94f3d78cac70a781093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#a041550377640f94f3d78cac70a781093">runPosTest</a> (uint8_t *saturated=NULL, uint32_t max_retries=0, float delay_time=<a class="el" href="group___general_constants.html#ga26afbcf737f1add055ea8929c03648a9">HMC_SLEEP_DELAY</a>)</td></tr>
<tr class="separator:a041550377640f94f3d78cac70a781093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6285036cc2d7c6f320b5eda766cf71e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#a6285036cc2d7c6f320b5eda766cf71e5">runNegTest</a> (uint8_t *saturated=NULL, uint32_t max_retries=0, float delay_time=<a class="el" href="group___general_constants.html#ga26afbcf737f1add055ea8929c03648a9">HMC_SLEEP_DELAY</a>)</td></tr>
<tr class="separator:a6285036cc2d7c6f320b5eda766cf71e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68af7d6a31a0ab313c6aa887512f861"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#ad68af7d6a31a0ab313c6aa887512f861">getStatus</a> (bool *isLocked, bool *isReady)</td></tr>
<tr class="separator:ad68af7d6a31a0ab313c6aa887512f861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d70ea9d043a7829d3410b6ed42d72d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#ac5d70ea9d043a7829d3410b6ed42d72d">setGain</a> (uint8_t gain_level)</td></tr>
<tr class="separator:ac5d70ea9d043a7829d3410b6ed42d72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6ab6cfe07eafee7d99012dc092e41d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#aed6ab6cfe07eafee7d99012dc092e41d">setAveragingRate</a> (uint8_t avg_rate)</td></tr>
<tr class="separator:aed6ab6cfe07eafee7d99012dc092e41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4eda2a75638936d50b25484b96147f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#a5c4eda2a75638936d50b25484b96147f">setOutputRate</a> (uint8_t out_rate)</td></tr>
<tr class="separator:a5c4eda2a75638936d50b25484b96147f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d584d734dfe62dad7ac7e32174285e9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#a6d584d734dfe62dad7ac7e32174285e9">setMeasurementMode</a> (uint8_t mode)</td></tr>
<tr class="separator:a6d584d734dfe62dad7ac7e32174285e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b858a870f8f961d5540a18393eabf0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#af5b858a870f8f961d5540a18393eabf0">setBiasMode</a> (uint8_t mode)</td></tr>
<tr class="separator:af5b858a870f8f961d5540a18393eabf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44596be4b636171ac21f3b80a6f46ee0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#a44596be4b636171ac21f3b80a6f46ee0">setHighSpeedI2CMode</a> (bool enabled)</td></tr>
<tr class="separator:a44596be4b636171ac21f3b80a6f46ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9eb6926b5f7461abbad1a63943071f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#aec9eb6926b5f7461abbad1a63943071f">getGain</a> (bool updateCache=false)</td></tr>
<tr class="separator:aec9eb6926b5f7461abbad1a63943071f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6652a9c55333f6fd2aac541f57a692fc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#a6652a9c55333f6fd2aac541f57a692fc">getAveragingRate</a> (bool updateCache=false)</td></tr>
<tr class="separator:a6652a9c55333f6fd2aac541f57a692fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2106f4efb55ac430b77b72485b9e57d6"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#a2106f4efb55ac430b77b72485b9e57d6">getOutputRate</a> (bool updateCache=false)</td></tr>
<tr class="separator:a2106f4efb55ac430b77b72485b9e57d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c29ddea7f0e5e142054944cfdae0ed5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#a4c29ddea7f0e5e142054944cfdae0ed5">getMeasurementMode</a> (bool updateCache=false)</td></tr>
<tr class="separator:a4c29ddea7f0e5e142054944cfdae0ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dee47519218c6d46c8c1c3121c5948b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#a3dee47519218c6d46c8c1c3121c5948b">getBiasMode</a> (bool updateCache=false)</td></tr>
<tr class="separator:a3dee47519218c6d46c8c1c3121c5948b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5045a220b5ed476f8eb38915c6571a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f5045a220b5ed476f8eb38915c6571a"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_error_code</b> (void)</td></tr>
<tr class="separator:a1f5045a220b5ed476f8eb38915c6571a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab3b98b1bbed0b767df657ce0a6630adc"><td class="memItemLeft" align="right" valign="top">static const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#ab3b98b1bbed0b767df657ce0a6630adc">outputRates</a> [] = {0.75, 1.50, 3.00, 7.50, 15.00, 30.00, 75.00}</td></tr>
<tr class="separator:ab3b98b1bbed0b767df657ce0a6630adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631541baef14a0c965430a685ca14504"><td class="memItemLeft" align="right" valign="top">static const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_m_c5883_l.html#a631541baef14a0c965430a685ca14504">gainRanges</a> [] = {880, 1300, 1900, 2500, 4000, 4700, 5600, 8100}</td></tr>
<tr class="separator:a631541baef14a0c965430a685ca14504"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab552ed5dd985c500aa37ac11f9ed3eed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HMC5883L::HMC5883L </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_h_m_c5883_l.html">HMC5883L</a> 3-axis digital magnetometer class object. </p>
<p>Constructor for <a class="el" href="class_h_m_c5883_l.html">HMC5883L</a> compass / magnetometer class. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6652a9c55333f6fd2aac541f57a692fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t HMC5883L::getAveragingRate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateCache</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the averaging rate</p>
<p>Retrieves the averaging rate that was set from <code><a class="el" href="class_h_m_c5883_l.html#aed6ab6cfe07eafee7d99012dc092e41d">setAveragingRate()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">updateCache</td><td>Boolean value, default <code>false</code>. If it evaluates as true, the gain level is retrieved from the device and cached in a private variable. Otherwise the value is retrieved from the cache.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> on no error. Returns I2C errors from call to <code><a class="el" href="class_i2_c_dev.html#a476fc2e973112f3a8ba9e2146d48ade9">I2CDev.read_data()</a></code> if <code>updateCache</code> is <code>true</code>. Otherwise no errors are returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a3dee47519218c6d46c8c1c3121c5948b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t HMC5883L::getBiasMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateCache</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the bias mode setting from the device</p>
<p>Retrieves the bias mode that was set from <code><a class="el" href="class_h_m_c5883_l.html#af5b858a870f8f961d5540a18393eabf0">setBiasMode()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">updateCache</td><td>Boolean value, default <code>false</code>. If it evaluates as true, the gain level is retrieved from the device and cached in a private variable. Otherwise the value is retrieved from the cache.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> on no error. Returns I2C errors from call to <code><a class="el" href="class_i2_c_dev.html#a476fc2e973112f3a8ba9e2146d48ade9">I2CDev.read_data()</a></code> if <code>updateCache</code> is <code>true</code>. Otherwise no errors are returned.</dd></dl>

</div>
</div>
<a class="anchor" id="afe8557a9869b1b8be968db2eb26eb373"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt; HMC5883L::getCalibration </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>saturated</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_retries</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay_time</em> = <code><a class="el" href="group___general_constants.html#ga26afbcf737f1add055ea8929c03648a9">HMC_SLEEP_DELAY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs a positive and negative bias test and sets the calibration from the average</p>
<p>Runs <code><a class="el" href="class_h_m_c5883_l.html#a041550377640f94f3d78cac70a781093">runPosTest()</a></code>, then <code><a class="el" href="class_h_m_c5883_l.html#a6285036cc2d7c6f320b5eda766cf71e5">runNegTest()</a></code> and averages the values, and sets the calibration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">update</td><td>If evaluates to true, run the calibration and update the cache. Otherwise just returns the cached value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*saturated</td><td>Warning flags in case any of the channels are saturated. Pass <code>NULL</code> if you don't want to read these out. Default value is <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_retries</td><td>The maximum number of times to try to read the measurement. Pass 0 if you don't want to limit the number of retries. Default is 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay_time</td><td>Time to delay before checking whether or not data is ready to be read from the device (also the repetition delay between checks for whether data is ready), in milliseconds. The default is <code>HMC_SLEEP_DELAY</code>, which is 7 ms (6.25 ms = 160 Hz, the maximum data output rate of the device, rounded up). Any non-negative value is valid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the new calibration value. On error, returns (0, 0, 0) and sets <code>err_code</code> to the error.</dd></dl>

</div>
</div>
<a class="anchor" id="aec9eb6926b5f7461abbad1a63943071f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t HMC5883L::getGain </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateCache</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the gain value</p>
<p>Retrieves the gain value level that was set from <code><a class="el" href="class_h_m_c5883_l.html#ac5d70ea9d043a7829d3410b6ed42d72d">setGain()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">updateCache</td><td>Boolean value, default <code>false</code>. If it evaluates as true, the gain level is retrieved from the device and cached in a private variable. Otherwise the value is retrieved from the cache.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> on no error. Returns I2C errors from call to <code><a class="el" href="class_i2_c_dev.html#a476fc2e973112f3a8ba9e2146d48ade9">I2CDev.read_data()</a></code> if <code>updateCache</code> is <code>true</code>. Otherwise no errors are returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a4c29ddea7f0e5e142054944cfdae0ed5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t HMC5883L::getMeasurementMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateCache</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the device's measurement mode</p>
<p>Retrieves the measurement mode that was set from <code><a class="el" href="class_h_m_c5883_l.html#a6d584d734dfe62dad7ac7e32174285e9">setMeasurementMode()</a></code>. If the cached mode is <code>HMC_MeasurementSingle</code>, the cache is always updated, irrespective of the value of <code>updateCache</code>, since the mode is set to <code>HMC_MeasurementIdle</code> when data is ready.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">updateCache</td><td>Boolean value, default <code>false</code>. If it evaluates as true, the gain level is retrieved from the device and cached in a private variable. Otherwise the value is retrieved from the cache.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> on no error. Returns I2C errors from call to <code><a class="el" href="class_i2_c_dev.html#a476fc2e973112f3a8ba9e2146d48ade9">I2CDev.read_data()</a></code> if <code>updateCache</code> is <code>true</code>. Otherwise no errors are returned.</dd></dl>

</div>
</div>
<a class="anchor" id="a2106f4efb55ac430b77b72485b9e57d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t HMC5883L::getOutputRate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateCache</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the data output rate in Continuous mode</p>
<p>Retrieves the data output rate that was set from <code><a class="el" href="class_h_m_c5883_l.html#a5c4eda2a75638936d50b25484b96147f">setOutputRate()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">updateCache</td><td>Boolean value, default <code>false</code>. If it evaluates as true, the gain level is retrieved from the device and cached in a private variable. Otherwise the value is retrieved from the cache.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> on no error. Returns I2C errors from call to <code><a class="el" href="class_i2_c_dev.html#a476fc2e973112f3a8ba9e2146d48ade9">I2CDev.read_data()</a></code> if <code>updateCache</code> is <code>true</code>. Otherwise no errors are returned.</dd></dl>

</div>
</div>
<a class="anchor" id="ad68af7d6a31a0ab313c6aa887512f861"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t HMC5883L::getStatus </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isLocked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isReady</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the status register</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">isLocked</td><td>Whether or not the status LOCK bit is set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isReady</td><td>Whether or not the status RDY bit is set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of the status register, or a value &gt;= 4 on error (no valid status register values are &gt; 3). On error, <code>err_code</code> is also set.</dd></dl>

</div>
</div>
<a class="anchor" id="adce69beed189b56b294775e273768b87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t HMC5883L::initialize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noConfig</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the magnetometer communications.</p>
<p>Starts I2C communication with the <a class="el" href="class_h_m_c5883_l.html">HMC5883L</a> magnetometer. This creates the Wire interface with the device. If the <code>noConfig</code> parameter is set to <code>false</code> (default), the magnetometer is also explicitly initialized with the device default values for the various configuration parameters:</p>
<table class="doxtable">
<tr>
<th align="left">Parameter </th><th align="left">Default value  </th></tr>
<tr>
<td align="left">Gain </td><td align="left"><code>[HMC_GAIN130]</code> 1090 LSb/Gauss (+/- 1.3 G sensor range) </td></tr>
<tr>
<td align="left">Averaging rate </td><td align="left"><code>[HMC_AVG1]</code> 1 point per sample </td></tr>
<tr>
<td align="left">Data output rate </td><td align="left"><code>[HMC_RATE1500]</code> 15 Hz </td></tr>
<tr>
<td align="left">Measurement mode </td><td align="left"><code>[HMC_MeasurementIdle]</code> Idle mode </td></tr>
<tr>
<td align="left">Bias mode </td><td align="left"><code>[HMC_BIAS_NONE]</code> No bias </td></tr>
</table>
<p>If <code>noConfig</code> is set to <code>true</code>, this will request the values of some of the parameters already set, so as to ensure the accuracy of calls to functions such as <code>getDelay()</code>, which may use cached values for compass parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">noConfig</td><td>Optional parameter. If specified <code>true</code>, explicitly initializes the device using default parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> on no error, or an error code. See <code>HMC5883L_Errors.h</code> for details.</dd></dl>

</div>
</div>
<a class="anchor" id="a6cc926cb263a856f4f3f77092d550139"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt; HMC5883L::readCalibratedValues </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>saturated</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the field vector, scaled by the calibration, in milliGauss.</p>
<p>Makes a call to <code><a class="el" href="class_h_m_c5883_l.html#ac270d4672e1e0ed759ee07a504f2ab00">readScaledValues()</a></code>, then scales the results by the calibration. By default, the calibration is (1.0, 1.0, 1.0). Make a call to <code>getCalibration(true)</code> to initialize the calibration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">*saturated</td><td>Warning flags in case any of the channels are saturated. Pass <code>NULL</code> if you don't want to read these out. Default value is <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of <code><a class="el" href="class_h_m_c5883_l.html#ac270d4672e1e0ed759ee07a504f2ab00">readScaledValues()</a></code>, scaled by the calibration, in mG. On error, returns (0, 0, 0) and sets the error code.</dd></dl>

</div>
</div>
<a class="anchor" id="acfb30a00675cd4a71809b103b06edfaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt; HMC5883L::readCalibratedValuesSingle </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>saturated</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_retries</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay_time</em> = <code><a class="el" href="group___general_constants.html#ga26afbcf737f1add055ea8929c03648a9">HMC_SLEEP_DELAY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the field vector, scaled by the calibration, in milliGauss.</p>
<p>Makes a single call to <code><a class="el" href="class_h_m_c5883_l.html#a16828549ee509bb4fa8a3995424c8889">readScaledValuesSingle()</a></code>, then scales the results by the calibration stored in the <code><a class="el" href="class_h_m_c5883_l.html">HMC5883L</a></code> object. By default, the calibration is <code>(1.0, 1.0, 1.0)</code>. Make a call to <code>getCalibration(true)</code> to initialize the calibration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">*saturated</td><td>Warning flags in case any of the channels are saturated. Pass <code>NULL</code> if you don't want to read these out. Default value is <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_retries</td><td>The maximum number of times to try to read the measurement. Pass 0 if you don't want to limit the number of retries. Default is 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay_time</td><td>Time to delay before checking whether or not data is ready to be read from the device (also the repetition delay between checks for whether data is ready), in milliseconds. The default is <code>HMC_SLEEP_DELAY</code>, which is 7 ms (6.25 ms = 160 Hz, the maximum data output rate of the device, rounded up). Any non-negative value is valid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of <code><a class="el" href="class_h_m_c5883_l.html#a16828549ee509bb4fa8a3995424c8889">readScaledValuesSingle()</a></code>, scaled by the calibration, in mG. On error, returns (0, 0, 0) and sets the error code.</dd></dl>

</div>
</div>
<a class="anchor" id="aef71c4ee9d0a549cb86f6bb90bb238b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_vec3.html">Vec3</a>&lt; int &gt; HMC5883L::readRawValues </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>saturated</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the raw values from the device</p>
<p>Values on the <a class="el" href="class_h_m_c5883_l.html">HMC5883L</a> are stored in the 6 data registers, in two's complement form, with each axis stored as two 8-bit integers (big-endian). This reads the raw integer values from the registers. For data under- and overflows, the registers are set to -4096 - this is detected and indicated with the output parameter <code>saturated</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">saturated</td><td>A warning code with flags <code>WC_X_SATURATED</code>, <code>WC_Y_SATURATED</code> and <code>WC_Z_SATURATED</code> indicating whether or not any of the channels has data under- or overflow.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an integer 3-vector (x, y, z), or (0, 0, 0) on</dd></dl>

</div>
</div>
<a class="anchor" id="ac270d4672e1e0ed759ee07a504f2ab00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt; HMC5883L::readScaledValues </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>saturated</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the field vector and return the value in milliGauss.</p>
<p>Scales the integers returned by <code><a class="el" href="class_h_m_c5883_l.html#aef71c4ee9d0a549cb86f6bb90bb238b2">readRawValues()</a></code> by the appropriate gain value determined by the value set by <code><a class="el" href="class_h_m_c5883_l.html#ac5d70ea9d043a7829d3410b6ed42d72d">setGain()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">*saturated</td><td>Warning flags in case any of the channels are saturated. Pass <code>NULL</code> if you don't want to read these out. Default value is <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="struct_vec3.html">Vec3</a>&lt;float&gt;</code> containing the scaled values for the x, y and z channels or (0, 0, 0) on error.</dd></dl>

</div>
</div>
<a class="anchor" id="a16828549ee509bb4fa8a3995424c8889"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt; HMC5883L::readScaledValuesSingle </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>saturated</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_retries</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay_time</em> = <code><a class="el" href="group___general_constants.html#ga26afbcf737f1add055ea8929c03648a9">HMC_SLEEP_DELAY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for <code><a class="el" href="class_h_m_c5883_l.html#ac270d4672e1e0ed759ee07a504f2ab00">readScaledValues()</a></code> which makes a single measurement</p>
<p>The device is put into single measurement mode, then wait <code>delay_time</code> (in milliseconds), a single <code><a class="el" href="class_h_m_c5883_l.html#ac270d4672e1e0ed759ee07a504f2ab00">readScaledValues()</a></code> measurement is made, then the measurement mode is restored to the initial mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">*saturated</td><td>Warning flags in case any of the channels are saturated. Pass <code>NULL</code> if you don't want to read these out. Default value is <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_retries</td><td>The maximum number of times to try to read the measurement. Pass 0 if you don't want to limit the number of retries. Default is 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay_time</td><td>Time to delay before checking whether or not data is ready to be read from the device (also the repetition delay between checks for whether data is ready), in milliseconds. The default is <code>HMC_SLEEP_DELAY</code>, which is 7 ms (6.25 ms = 160 Hz, the maximum data output rate of the device, rounded up). Any non-negative value is valid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <code><a class="el" href="struct_vec3.html">Vec3</a>&lt;float&gt;</code> containing the scaled values for the x, y and z channels or (0, 0, 0) on error. In addition to errors returned from <code>I2CDevice</code> calls, this returns <code>EC_INVALID_UFLOAT</code> if a negative <code>delay_time</code> is passed.</dd></dl>

</div>
</div>
<a class="anchor" id="a6285036cc2d7c6f320b5eda766cf71e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt; HMC5883L::runNegTest </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>saturated</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_retries</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay_time</em> = <code><a class="el" href="group___general_constants.html#ga26afbcf737f1add055ea8929c03648a9">HMC_SLEEP_DELAY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs the negative bias self-test</p>
<p>Sets the bias mode to <code>HMC_BIAS_NEGATIVE</code>, makes a measurement, then returns the bias mode to <code>HMC_BIAS_NONE</code> and returns the value of the measurement.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of a negative-biased measurement. On error, returns (0, 0, 0) and sets <code>err_code</code> to the error.</dd></dl>

</div>
</div>
<a class="anchor" id="a041550377640f94f3d78cac70a781093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_vec3.html">Vec3</a>&lt; float &gt; HMC5883L::runPosTest </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>saturated</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_retries</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay_time</em> = <code><a class="el" href="group___general_constants.html#ga26afbcf737f1add055ea8929c03648a9">HMC_SLEEP_DELAY</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs the positive bias self-test</p>
<p>Sets the bias mode to <code>HMC_BIAS_POSITIVE</code>, makes a measurement, then returns the bias mode to <code>HMC_BIAS_NONE</code> and returns the value of the measurement.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the value of a positive-biased measurement. On error, returns (0, 0, 0) and sets <code>err_code</code> to the error.</dd></dl>

</div>
</div>
<a class="anchor" id="aed6ab6cfe07eafee7d99012dc092e41d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t HMC5883L::setAveragingRate </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>avg_rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the magnetometer averaging rate.</p>
<p>This is the number of averages composing each measurement. It sets bits 5 and 6 on Configuration Register A on the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">avg_rate</td><td>The averaging rate. The number of averages per measurement is 1&lt;&lt;avg_rate.</td></tr>
  </table>
  </dd>
</dl>
<table class="doxtable">
<tr>
<th align="left"><code>avg_rate</code> </th><th align="center">Value </th><th align="center">Rate  </th></tr>
<tr>
<td align="left"><code>HMC_AVG1</code> </td><td align="center">0 </td><td align="center">1 </td></tr>
<tr>
<td align="left"><code>HMC_AVG2</code> </td><td align="center">1 </td><td align="center">2 </td></tr>
<tr>
<td align="left"><code>HMC_AVG4</code> </td><td align="center">2 </td><td align="center">4 </td></tr>
<tr>
<td align="left"><code>HMC_AVG8</code> </td><td align="center">3 </td><td align="center">8 </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> on no error. Otherwise returns error code. Returns I2C errors from calls to <code>read_data()</code> and <code>write_data()</code>, as well as:<ul>
<li><code><code>EC_INVALID_NAVG</code></code> Returned if the number of averages is out of range.</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af5b858a870f8f961d5540a18393eabf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t HMC5883L::setBiasMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the measurement bias mode (negative, positive or none).</p>
<p>The <a class="el" href="class_h_m_c5883_l.html">HMC5883L</a> has a self-test mode which applies either a negative or positive bias field along all three channels; the mode is set in the bottom two bits of the Configuration Register A. The applied bias fields along all three axes are:</p>
<table class="doxtable">
<tr>
<th align="center">Axis </th><th align="left">Bias-on field (mG)  </th></tr>
<tr>
<td align="center">X </td><td align="left">±1160 </td></tr>
<tr>
<td align="center">Y </td><td align="left">±1160 </td></tr>
<tr>
<td align="center">Z </td><td align="left">±1080 </td></tr>
</table>
<p>In the negative and positive bias modes, each "measurement" consists of two measurements, a measurement with the bias field applied and one without, and the device returns the difference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Valid bias modes are <code>HMC_BIAS_NONE</code> [0], <code>HMC_BIAS_POSITIVE</code> [1] and <code>HMC_BIAS_NEGATIVE</code> [2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> on no error. Returns I2C errors from calls to <code><a class="el" href="class_i2_c_dev.html#a476fc2e973112f3a8ba9e2146d48ade9">I2CDev.read_data()</a></code> and <code><a class="el" href="class_i2_c_dev.html#ae9c3d3479298e87151ac07c73f734b68">I2CDev.write_data()</a></code></dd></dl>

</div>
</div>
<a class="anchor" id="ac5d70ea9d043a7829d3410b6ed42d72d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t HMC5883L::setGain </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gain_level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the magnetometer gain value.</p>
<p>Sets the magnetometer gain value, which determines the sensor range and the digital resolution. The gain level is bits 5-7 of Configuration Register B. The rest of configuration register B should be 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gain_level</td><td>The gain setting, the values for which can be found in the following table:</td></tr>
  </table>
  </dd>
</dl>
<table class="doxtable">
<tr>
<th align="left"><code>gain_level</code> </th><th align="center">Value </th><th align="center">Gain (LSB/G) </th><th align="center">Range (G) </th><th align="center">Resolution (mG / LSB)  </th></tr>
<tr>
<td align="left"><code>HMC_GAIN088</code> </td><td align="center">0 </td><td align="center">1370 </td><td align="center">±0.88 </td><td align="center">0.73 </td></tr>
<tr>
<td align="left"><code>HMC_GAIN130</code> </td><td align="center">1 </td><td align="center">1090 </td><td align="center">±1.30 </td><td align="center">0.92 </td></tr>
<tr>
<td align="left"><code>HMC_GAIN190</code> </td><td align="center">2 </td><td align="center">820 </td><td align="center">±1.90 </td><td align="center">1.22 </td></tr>
<tr>
<td align="left"><code>HMC_GAIN250</code> </td><td align="center">3 </td><td align="center">660 </td><td align="center">±2.50 </td><td align="center">1.52 </td></tr>
<tr>
<td align="left"><code>HMC_GAIN400</code> </td><td align="center">4 </td><td align="center">440 </td><td align="center">±4.00 </td><td align="center">2.27 </td></tr>
<tr>
<td align="left"><code>HMC_GAIN470</code> </td><td align="center">5 </td><td align="center">390 </td><td align="center">±4.70 </td><td align="center">2.56 </td></tr>
<tr>
<td align="left"><code>HMC_GAIN560</code> </td><td align="center">6 </td><td align="center">330 </td><td align="center">±5.60 </td><td align="center">3.03 </td></tr>
<tr>
<td align="left"><code>HMC_GAIN810</code> </td><td align="center">7 </td><td align="center">230 </td><td align="center">±8.10 </td><td align="center">4.35 </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> on no error. Otherwise returns error code. Returns I2C errors from calls to <code>write_data()</code>, as well as:<ul>
<li><code><code>EC_BAD_GAIN_LEVEL</code></code> Returned if input gain level is out of range.</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a44596be4b636171ac21f3b80a6f46ee0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t HMC5883L::setHighSpeedI2CMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable High Speed I2C (3400 kHz)</p>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> on no error. returns I2C errors from calls to <code><a class="el" href="class_i2_c_dev.html#a476fc2e973112f3a8ba9e2146d48ade9">I2CDev.read_data()</a></code> and <code><a class="el" href="class_i2_c_dev.html#ae9c3d3479298e87151ac07c73f734b68">I2CDev.write_data()</a></code>.</dd></dl>

</div>
</div>
<a class="anchor" id="a6d584d734dfe62dad7ac7e32174285e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t HMC5883L::setMeasurementMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the measurement mode (Continuous, Single or Idle).</p>
<p>Measurement mode is the first two bits of the mode register. In continuous mode, data is output at the rate set by <code>setOutputRate</code>. In single measurement mode, a single measurement is made, the RDY pin is set high and mode is returned to idle. In single measurement mode, the approximate maximum data rate is 160 Hz. Idle is self-explanatory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The measurement mode, <code>HMC_MeasurementContinuous</code> [0], <code>HMC_MeasurementSingle</code> [1], <code>HMC_MeasurementIdle</code> [2].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> on no error. Returns I2C errors from calls to <code><a class="el" href="class_i2_c_dev.html#a476fc2e973112f3a8ba9e2146d48ade9">I2CDev.read_data()</a></code> and <code><a class="el" href="class_i2_c_dev.html#ae9c3d3479298e87151ac07c73f734b68">I2CDev.write_data()</a></code>, as well as:<ul>
<li><code><code>EC_INVALID_MEASUREMENT_MODE</code></code> Returned if the measurement mode is out of range.</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5c4eda2a75638936d50b25484b96147f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t HMC5883L::setOutputRate </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>out_rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the data output rate in continuous output mode.</p>
<p>Data output rate in continuous mode. Value is set in bits 2-4 of configuration register A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out_rate</td><td>The data output rate. Valid values are 0-6:</td></tr>
  </table>
  </dd>
</dl>
<table class="doxtable">
<tr>
<th align="left"><code>out_rate</code> </th><th align="center">Value </th><th align="center">Rate (Hz)  </th></tr>
<tr>
<td align="left"><code>HMC_RATE0075</code> </td><td align="center">0 </td><td align="center">0.75 </td></tr>
<tr>
<td align="left"><code>HMC_RATE0150</code> </td><td align="center">1 </td><td align="center">1.50 </td></tr>
<tr>
<td align="left"><code>HMC_RATE0300</code> </td><td align="center">2 </td><td align="center">3.00 </td></tr>
<tr>
<td align="left"><code>HMC_RATE0750</code> </td><td align="center">3 </td><td align="center">7.50 </td></tr>
<tr>
<td align="left"><code>HMC_RATE1500</code> </td><td align="center">4 </td><td align="center">15.00 </td></tr>
<tr>
<td align="left"><code>HMC_RATE3000</code> </td><td align="center">5 </td><td align="center">30.00 </td></tr>
<tr>
<td align="left"><code>HMC_RATE7500</code> </td><td align="center">6 </td><td align="center">75.00 </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>0</code> on no error. Returns I2C errors from calls to <code><a class="el" href="class_i2_c_dev.html#a476fc2e973112f3a8ba9e2146d48ade9">I2CDev.read_data()</a></code> and <code><a class="el" href="class_i2_c_dev.html#ae9c3d3479298e87151ac07c73f734b68">I2CDev.write_data()</a></code>, as well as:<ul>
<li><code><code>EC_INVALID_OUTRATE</code></code> Returned if the output rate is out of range.</li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a631541baef14a0c965430a685ca14504"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float HMC5883L::gainRanges = {880, 1300, 1900, 2500, 4000, 4700, 5600, 8100}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saturation ranges in mG. See <a class="el" href="group___gain_settings.html">Gain settings</a> </p>

</div>
</div>
<a class="anchor" id="ab3b98b1bbed0b767df657ce0a6630adc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float HMC5883L::outputRates = {0.75, 1.50, 3.00, 7.50, 15.00, 30.00, 75.00}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output rates in Hz (see <a class="el" href="group___output_rates.html">Output rate settings</a>). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_h_m_c5883_l_8h_source.html">HMC5883L.h</a></li>
<li><a class="el" href="_h_m_c5883_l_8cpp.html">HMC5883L.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_h_m_c5883_l.html">HMC5883L</a></li>
    <li class="footer">Generated on Sat Jan 24 2015 14:09:30 for HMC5883L by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
